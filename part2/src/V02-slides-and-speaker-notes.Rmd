---
title: "Introduction to R, Module 2"
author: "Steve Simon"
date: "Created 2020-02-08"
output: powerpoint_presentation
---

### Introduction

This program how to manipulate a simple set of data and produce a few descriptive statistics.

```{r version-and-current-date}
R.version.string
Sys.Date()
```

<div class="notes">

At the beginning of every program, you should include a brief explanation and print out the version of R that you are using and the date that the program was run. This is optional, but is one of the documentation practices that you should get in the habit of using.

</div>

### A brief comment about R Markdown.

+ R Markdown
  + Mixture of free text commentary 
+ Use of backticks (`)
  + Delineates chunks of R code
  + Three backticks followed by {r}
  + R code
  + Three more backticks

<div class="notes">

This file is written in R Markdown, a mixture of R commands and commentary. Lines surrounding the R commands start with three backquotes. The line at the top will also have curlybraces a lower case "r" and brief descriptive names of the code segment (e.g., read). The backquotes and curly braces allow me to produce a nicely formatted html file that intersperses the R commands, the R output, and the commentary.

You can safely ignore the backquotes and curly braces. Use cut-and-paste from a text editor like notepad to run the appropriate commands without having to retype them. Please cut-and-paste the thre lines below into the R console.

</div>

```{r simple-example}
x <- 1:9
x
summary(x)
```

You are not responsible for R Markdown in this class, but I wanted to show you one of the features of R Markdown. When you create objects in R, you can print those objects, as shown above, or you can incorporate those objects in your commentary. Here's an example.

Our data set has values `r x`. The mean is `r mean(x)` and the standard deviation is `r sd(x)`

### Cleaning house

```{r clean-house}
ls()
rm(list=ls()) # This list=ls() option removes everything
```

<div class="notes">

When I start up a new program, I usually take the time to remove any objects that might be left over from a previous program. It isn't really necessary, but sometimes it can help avoid some problems. You can take a look at what objects are currently available in memory with the ls function and you can remove some or all of these objects with the rm function.

</div>

### Some definitions

+ Categorical = small number of possible values
+ Examples
  + sex (Male or Female),
  + race/ethnicity (Caucasian, African American, Hispanic, etc.),
  + cancer stage (I, II, III, or IV),
  + birth delivery type (Vaginal, C-section). 

<div class="notes">

A **categorical variable** is a variable that can only take on a small number of values. Each value is usually associated with a particular category.

</div>

### Some definitions
+ Continuous variable = large number of possible values
+ Examples of continuous variables are
  + Birth weight in grams,
  + gestational age,
  + fasting LDL level.

<div class="notes">

A **continuous variable** is a variable that can take on a large number of possible values, potentially any value in some interval.

There are some variables that are on the boundary between categorical and continuous, but it is not worth quibbling about here. 

The point to remember is that the types of graphs that you use and the types of statistics that you compute are dependent on many things, but first and foremost on whether the variables are categorical, continuous, or a mixture.

Today, you will see examples involving mostly continuous variables.

</div>

### Body fat measures

<div class="notes">

The first data set we will work with shows data various body measurements. A brief description of this file is available at

--> http://www.amstat.org/publications/jse/datasets/fat.txt

You need to read in the file using the read.table function.

</div>

### Load data

```{r read}
load("../dat/d.RData")
ls()
```

### Print data

```{r print}
bump
```

###

R has many of the features of an object-oriented language, but it is not a true object-oriented programming language. There are a variety of objects in R like vectors, lists, matrices, and arrays, that are useful for storing, manipulating, and analyzing research data. We will spend most of this class using a particular object, the data frame.

The object, fd, that you just created with the read.table function is a data frame. Data frames are rectangular grids of data. Each column in the data frame has the same length. A data frame can store data of various types (numeric, character, and dates are the most common types of data). The data within a column has to have the same type, but the different columns can have different data types.

There are times when the rectangular grid of a data frame is too restrictive for your data, and R has other ways of storing this data (most notably, lists), but you will find that for most data analyses, a data frame will work just fine.

The head function shows the first few rows of the data set and the tail function shows the last few rows of the data set.

Always get in the habit of checking out the very bottom of your data frame. It's a common location for glitches.

This data set did not have a header, a line at the very top of the file that lists variable names. R uses the default names V1, V2, etc. As a general rule, you should use brief (but descriptive) names for every variable in your data set. The names should be around 8 characters long. Longer variable names make your typing tedious and much shorter variable names makes your code terse and cryptic.

You should avoid special symbols in your variable names especially symbols that are likely to cause confusion (the dash symbol, for example, which is also the symbol for subtraction). You should also avoid blanks. These rules are pretty much universal across most statistical software packages. If you violate these rules, you will find out that, at a minimum, you will always have to surround your variable name by quotes to avoid problems.

There are times when you'd like to have a blank in your variable name and you can use two special symbols that you can use in R (and most other statistical pacakges), the underscore symbol (above the minus key on most keyboards) and the dot (period). These symbols create some artificial spacing that mimics the blanks. Another approach is "CamelCase" which is the mixture of upper and lower case within a variable name with each uppercase designating the beginning of a new "word".

### Displaying variable names

```{r names-1}
names(fd)
```

### Changing variable names

```{r names-2}
names(fd) <- c("case","fat.b","fat.s","dens","age","wt","ht","bmi","ffw","neck","chest","abdomen","hip","thigh","knee","ankle","biceps","forearm","wrist")
```

<div class="notes">

You also can use the names function to create a different set of variable names.

</div>

### More notes

I'm a bit more terse with these variable names than I normally would be just to reduce the amount of typing you have to do.

Now, when you display part or all of your data frame, the new names will help you navigate successfully through it.

### Head function

```{r names-3}
head(fd)
```

<div class="notes">

Most statistical packages allow you to provide a longer description for each variable in your dataset (a variable label, for example, in SPSS). The longer descriptions have almost no restrictions on blanks or special symbols and are useful for documenting the units of measurement for your variable, among other things. R does not have a formal equivalent to the SPSS variable label.

We'll talk about additional documentation requirements for categorical data in part 2 of this class.

I'm going to take a short break and you can also. Before you take your break, save your work. The save.image function stores a binary version of all your objects.

</div>

<div class="notes">

To list the entire data frame, just type the name. In R, when you type the name of an object, it knows that you want a display of what is in that object. To list just part of a data frame, you can use a matrix style of notation.

</div>

```{r single-column}
fd
fd[1, 1] # first row, first column
fd[1, ] # all columns for first row
fd[, 1] # all rows for first column
fd[1, "ht"] # first row, "ht" column
fd[1:50, "ht"] # first fifty rows, "ht" column
```

### Dollar sign

```{r dollar-sign}
fd$ht # all rows for "ht" column
fd$ht[1:50] # first fifty rows for "ht" column
# Notice that fd$ht[1:50] and fd[1:50, "ht"] produce the same results.
```

<div class="notes">

There is a short cut for displaying a particular column that uses the dollar sign. Notice how the subset of fd$ht differs from the subset of the entire data frame.

</div>

### On your own (do this, but you do not need to turn in anything to me)

Display the first ten rows and the first five columns of your data.

### Break
+ End of part 1
+ Start of part 2

### Unusual data value

There is an unusual data value, which you might not notice right away, but one of the heights is 29.5 inches. We'll talk in more detail about the summary function later, but right now I wanted to show you function because if you have an outlier in your data, you are most likely to discover it by using the summary function.

```{r summary-of-ht}
summary(fd$ht)
```

<div class="notes">

A height this small is not totally out of the realm of possibility. See, for example, 

--> http://en.wikipedia.org/wiki/List_of_shortest_people

You can use the which function to identify the row with this unusual value for further investigation. Note the use of the double equals sign and how you display a single row of a data frame.

</div>

### Which function

```{r which}
which(fd$ht==29.5)
fd[which(fd$ht==29.5), ]
```

<div class="notes">

The other values look quite normal. You have to make a careful choice here. One possibility is to do nothing. If you leave the abnormal height in your data set, it may distort some of your graphs and skew some of your statistics. Still, it is often BETTER than some of the alternatives.

A second choice is to remove the entire row from the data frame. The -42 means everything EXCEPT row 42.

</div>

### Remove

```{r remove}
fd1 <- fd[-42,]
fd1$ht
```

<div class="notes"

A third possibility is to designate the abnormal value as missing. In R, a missing value is represented by NA.

</div>

```{r missing}
fd2 <- fd
fd2[42,"ht"] <- NA
fd2$ht
```

<div class="notes">

There is no one method that is preferred in this setting. If you encounter an unusual value, you should discuss it with your research team, investigate the original data sources, if possible, and review any procedures for handling unusual data values that might be specified in your research protocol.

Your data set may arrive with missing values in it already. Data might be designated as missing for a variety of reasons (lab result lost, value below the limit of detection, patient refused to answer this question) and how you handle missing values is way beyond the scope of this class. Just remember to tread cautiously around missing values as they are a minefield.

Notice that I store the revised data sets with the row removed and with the 29.5 replaced by a missing value in different data frames. This is good programming practice. If you ever have to make a destructive change to your data set (a change that wipes out one or more values or a change that is difficult to undo), it is good form to store the new results in a fresh spot. That way, if you get cold feet, you can easily backtrack.

We'll use the data set with the 29.5 changed to a missing value for all of the remaining analyses of this data set.

</div>

### On your own (do this, but you do not need to turn in anything to me)

Display the data for the wt variable and use the summary function. Are there any obvious outliers for weight?

### Break
+ End of part 2
+ Start of part 3

### Summary

Notice that the summary function for the ht variable notes that one of the values is missing. You should watch these missing values obsessively. This can get a bit tricky. 

```{r tracking-missing-1}
which(fd2$ht==NA)
```

<div class="notes">

Logic involving missing values is tricky. If you checking for equality and one of the things in the comparison is missing, then the result is neither TRUE, not FALSE, but rather missing.

Fair enough, but R takes it a bit further, and if both sides when you are checking for equality are missing, then they might both be 5 is they weren't missing or maybe one might be 5 and the other one 10. So it might be TRUE or it might be FALSE, so we're better off calling the logical result as missing.

This is called a three valued logic system and it has advantages and disadvantages. I won't get into any technical details, except to say that you should never make assumptions. Check what you do when you are working with missing values to make sure that the three valued logic system doesn't produce results that you didn't expect.

</div>

### is.na

The short term solution to the above problem is to use a special function, is.na.

```{r tracking-missing-2}
which(is.na(fd2$ht))
```

The summary function will trap and remove missing values, but most other functions in R will, by default, report a result as missing if any values going into that function are missing. The philosophy in R, I suppose, is that you need to actively select an approach for handling missing values rather than relying on a lazy default. Also, a  missing value is less likely to evade your notice when you have to actively specify an approach for handling the missing values.

```{r mean-sd-1}
mean(fd2$ht)
sd(fd2$ht)
```

<div class="notes">

Read the help file for these functions (enter ?mean or ?sd at the command prompt).

Look carefully and note that the na.rm option allows you to compute the statistic after missing values are removed.

</div>

### na.rm

```{r mean-sd-2}
mean(fd2$ht,na.rm=TRUE)
sd(fd2$ht,na.rm=TRUE)
```

<div class="notes">

For univariate functions, there are only two realistic ways to handle missing values, but for bivariate and multivariate function, there are a multitude of approaches, such as pairwise deletion, listwise deletion, last observation carried forward, single imputation, and multiple imputation. There is a lot of controversy over various methods for handling missing values.

</div>

### Histogram

A histogram is useful for displaying a continuous variable graphically.

```{r histogram-1}
hist(fd2$bmi)
```

<div class="notes">

Look at the help function for the hist function. The breaks argument allows you to control where the bars appear and how many bars you have. So, for example, the default scaling for the ht variable is 2 inches per bar, but you can make the bars narrower (one inch per bar), start at 60 inches (5 feet), and go all the way up to 84 inches (7 feet).

Always start with the default option, but don't settle for it.

</div>

### New slide

```{r histogram-2}
hist(fd2$ht)
```

<div class="notes">

The main, xlab, and ylab argument control some of the documentation displayed on the graph.

</div>

### New slide 

```{r histogram-3}
hist(fd2$ht,breaks=60:84,main=" ",xlab="Height in inches")
```

<div class="notes">

Finally, you can control the labelling of the axes by specifying axes=FALSE (to avoid the default axes, and then using the axis command to put the tick marks and labels where you want them).

</div>

### New slide 

```{r histogram-4}
hist(fd2$ht,breaks=c(60,66,72,78,84),main=" ",xlab="Height",axes=FALSE)
lb <- c("5ft to 5ft 6in","5ft 7in to 6ft",
        "6ft to 6ft 6in","6ft 7in to 7ft")
axis(side=1,at=c(63,69,75,81),labels=lb)
axis(side=2,at=50*(0:4))
```

<div class="notes">

You haven't created any new data frames, but save eveything anyway.

</div>

### New slide 

<div class="notes">

Suppose you create a large amount of text output in R. You can do this by running the following commands

</div>

### New slide 

```{r lots-of-output}
str(fd2)
summary(fd2)
```

<div class="notes">

There are many ways that you can do this. The simplest is to highlight the output, copy it to the clipboard and then paste it into another program.

You can also direct R output to a text file with the sink function.

</div>

### New slide 

```{r sink-example}
sink("../results/summary.txt")
summary(fd2)
sink()
```

<div class="notes">

It's important when you're done to turn the sink function off with a call to the sink function with no arguments.

Pasting into Excel is tricky, because you fit individual tabular data elements into individual cells. Sometimes you can do better by saving the output from a function like summary to an object and then exporting that object to a csv file.

</div>

### New slide 

```{r write-to-csv}
overall_summary <- summary(fd2)
str(overall_summary)
fn <- "../results/summary.csv"
write.csv(overall_summary, file=fn)
```

<div class="notes">

Whether exporing to a csv file works or not will depend a lot on the structure of the output. Summary produces an object of type 'table' (see the help file for table if you're curious what) and this object exports very nicely to Excel. Other objects may not export as well. In general, the output from a function needs to have a rectangular shape for this method to work.

Powerpoint is also tricky because you have to cut-and-paste in bite-sized pieces.

There are several ways to export graphs. First, let's draw a graph.

</div>

### New slide 

```{r draw-a-graph}
hist(fd2$ht)
```

<div class="notes">

You can click on the graphics window to export the graph. You can also explicitly export a graph using the bmp, jpeg, pdf, png, or tiff functions.

</div>

### New slide 

```{r export-bmp}
bmp(filename="../results/histogram.bmp")
hist(fd2$ht)
dev.off()
```

<div class="notes">

It is VERY important to turn off the exporting function before you try to use the file. Also, you need to experiment with various sizes through the width and height arguments to these functions.

We created a new object (overall_summary), so you might want to save things here before proceeding to the next section.

</div>

### Break

+ End of part 3
+ Start of part 4 

<div class="notes">

Before you go, please answer the following quiz question.

1. What function in R creates a graphic file in BMP format?

Please also take this opportunity to ask any questions you might have.

Send the answers to the quiz by email with the subject line

Introduction to R, (your name), quiz 1g. 

</div>

### New slide

<div class="notes">

The correlation coefficient is a single number between -1 and +1 that quantifies the strength and direction of a relationship between two continuous variables. As a rough rule of thumb, a correlation larger than +0.7 indicates a strong positive association and a correlation smaller than -0.7 indicates a strong negative association. A correlation between +0.3 and +0.7 (-0.3 and -0.7) indicates a weak positive (negative) association. A correlation between -0.3 and +0.3 indicates little or no association.

Don't take these rules too literally. You're not trying to make definitive statements about your data set. You are just trying to get comfortable with some general patterns that occur in your data set. A complex and definitive statistical analysis will almost certainly not agree with at least some of the preliminary correlations noted here.

</div>

### Correlation matrices

```{r corr-1}
cor(fd2$fat.b,fd2$age)
```

<div class="notes">

You can get a matrix of correlations for every possible pair of variables. This command becomes a bit more complicated if there are some categorical variables in your data set, as you need to exclude these prior to calculating the correlation matrix. Since you are just trying to get a general feel for your data, a bit of rounding will help you. Also, you should remove the case number before calculating the correlation matrix.

</div>

### New slide 

```{r corr-2}
cor(fd2[ ,-1])
round(cor(fd2[,-1]),2)
round(100*cor(fd2[,-1]))
```

<div class="notes">

You can get pieces of the correlation matrix by supplying pieces of the data frame.

</div>

### New slide 

```{r corr-3}
leg.measures <- c("hip","thigh","knee","ankle")
arm.measures <- c("biceps","forearm","wrist")
round(100*cor(fd2[,leg.measures],fd2[,arm.measures]))
```

<div class="notes">

We created a few new objects, so you might want to save things here before proceeding to the next section.

The best graphical way to display a relationship between two continuous variables is a scatterplot.

</div>

### New slide 

```{r scatterplot-1}
plot(fd2$abdomen,fd2$fat.b)
plot(fd2$ht,fd2$abdomen)
```

<div class="notes">

There are lots of options available to customize your graph. Here are just a few. The xlab and ylab arguments in the plot function control what is displayed on the horizontal (x) and vertical (y) axes. The pch argument control what is used as the plotting character.

</div>

### New slide 

```{r scatterplot-2}
plot(fd2$abdomen/2.54,fd2$fat.b,
     xlab="Abdomen circumference in inches",
     ylab="Percentage of body fat using Brozek's equation",
     pch="+")
title("Figure 1. My brilliant graph.")
```

<div class="notes">

Notice that you can do the units conversion "on the fly". This doesn't work on all functions.

These scatterpltos often benefit by adding a trend line.

Here's a linear regression trend line

</div>

### Adding trend lines

```{r trend-1}
fd2$abdomen.in <- fd2$abdomen/2.54
trend.line <- lm(fat.b~abdomen.in,data=fd2)
plot(fd2$abdomen.in,fd2$fat.b)
abline(trend.line)
```

<div class="notes">

Here's a smooth curve.

</div>

### New slide 

```{r trend-2}
smooth.curve <- lowess(fd2$age,fd2$fat.b)
plot(fd2$age,fd2$fat.b)
lines(smooth.curve)
```

<div class="notes">

There is a second data set on sleep in mammals. You can find a brief description of this data set at

--> http://www.statsci.org/data/general/sleep.html

and you can download the actual data at

--> http://www.statsci.org/data/general/sleep.txt

Notice that the last three variables are ordinal, but for the purposes of this class, we will treat them the same as the other variables.

</div>

### Read the file into R

<div class="notes">

Notice that this file has variable names at the very top. Look at the help file for read.table and see what option you might choose here. Display the first few rows and the last few rows.

As noted in each of the R commands shown below, I will remove the answers before I distribute this file to the students.

</div>

### New slide 

```{r read-sleep}
fn <- "http://www.statsci.org/data/general/sleep.txt"
sl <- read.table(file=fn,header=TRUE)
head(sl)
tail(sl)
```

<div class="notes">

Your homework assignment for Part 1 is available at http://www.pmean.com/15/images/homework.html.

If there is time, a third data set is described at

--> http://www.amstat.org/publications/jse/datasets/body.txt

and the data itself is at

--> http://www.amstat.org/publications/jse/datasets/body.dat.txt

We created a few new objects, so you might want to save things here before proceeding to the next section.

</div>

### New slide 

<div class="notes">


The material for Part 1 did not include enough information about getting data into and out of R. Here are a few extra examples.

</div>

### Read in comma separated values

<div class="notes">

The read.csv function will read a text file with commas separating individual data points. This is a commonly used format and frequently has the extension .csv.

In notepad or another text editor, type in the following
values.

1,4

2,8

3,12

4,16

and save the file using the name simple.csv. Note the directory that you are saving it in.

Here's a time saving hint: run the getwd function without any arguments (getwd()) to see where the current working directory. This is the place that R is currently looking for files if you don't provide a path. If you store the file simple.csv in the current working directory, then you don't have to type in the path name as well as the filename.

You can use the setwd command to change the current working directory. Be sure to use forward slashes (/) in your pathname rather than backslashes (\).

</div>

### New slide 

```{r read-csv}
fn <- "../dat/simple.csv"
d1 <- read.csv(file=fn)
d1
```

<div class="notes">

Oops! That didn't work the way I wanted it to. Look at the help file for read.csv. What option would you use to avoid losing the first line of data?

### On your own  (do this, but you do not need to turn in anything to me)

Add the line x,y to the top of your csv file and read it in using the header=TRUE option.

Note: depending on how you typed your data, you may or may not get an error message like "Warning in readLines(file, n = thisblock): incomplete final line found"

This happens when R does not find a carriage return at the end of the last line of data. This is easily fixed by opening the text file and going to the very end with CTRL-END.

if you land at the end of the very last line, you don't have a final carriage return. If you land on a blank line below the last line of text, then you are fine.

### Using the more general function, read.table

<div class="notes">

Review the options for the read.table command.

Type in the same data, but using the tilde (~) as a separator (e.g., 1~4). Save the file as tilde.txt.

Here is how you would use read.table to read this file.

</div>

### Reading in space delimited files.

```{r read-table}
fn <- "../dat/tilde.txt"
d2 <- read.table(file=fn,header=TRUE,sep="~")
```

<div class="notes">

Open up notepad and type in the following lines.

1  4

2  8

3 12

4 16

Be sure to line up the numbers properly by inserting two blanks between 1 and 4 and two blanks between 2 and 8, but only one blank between 3 and 12 and between 4 and 16.

Save the file as space.txt.

If you tried to read in the file with sep=" ", you would get an error. Try this to see what the error looks like.


You can either always edit the file and replace any double blanks with single blanks, but if you look carefully at the help file, you will see that the argument sep="" (which is the default) will use white space (one or more blanks, tabs, carriage returns, or newlines). This works pretty well but not always. We will see a file where you have to fix things before you can import it properly.

</div>

### New slide 

```{r read-space}
fn <- "../dat/space.txt"
# Try read.table(fn,sep=" ") first.
d3 <- read.table(fn,sep="")
```

<div class="notes">

Note that the default for read.table is header=FALSE, as opposed to the default of HEADER=TRUE for read.csv.

</div>

### Reading fixed width format files

<div class="notes"

Sometimes you will get a file with no delimiters to save space. This requires that each variable takes up a fixed number of columns and that information is often specified in a separate file.

Create a fixed width file in notepad with the following lines.

1 4

2 8

312

416

and store it as fixed.txt.

</div>

### New slide 

```{r fixed}
fn <- "../dat/fixed.txt"
d4 <- read.fwf(fn,c(1,2))
d4
```

<div class="notes">

You should also consider the read.fortran function. Check out the help file.

### Writing text files

If you want to write a text file, you can use either the write.csv or write.table functions. Look up the help files on these functions. We'll create a small data frame and store it in a comma delimited and tab delimited format.

</div>

### New slide 

```{r write-text}
d5 <- data.frame(x=c(13,12,11),y=c(2,4,6))
fn <- "../results/output1.csv"
write.csv(d5,fn)
fn <- "../results/output2.txt"
write.table(d5,fn)
```

<div class="notes">

Open these files in notepad to see what they look like.

</div>

### On your own (do this, but you do not need to turn it anything to me)

To avoid the extra line at the top and the row names "1","2","3" use the options header=FALSE and col.names=FALSE. Try this and see what the two files look like now.

### Writing binary files

By default, R saves everything that you create on exiting from the program and stores it in a file with no name and with an extension of RData (in other words, .RData). This file is automatically loaded the next time you start R from the same subdirectory.

If you want to save a data frame in binary format, use the function save(). Binary formats are much faster but are pretty much useful only within R itself.

In other words, don't send a binary file to someone who does not have R. Binary files are useful when you are moving data from one R user to another, or data from one computer to another, or sometimes when you are moving data from one folder to another.


I had a student ask, “What, exactly, do I need to turn in for the homework assignments. I said that I’d like to see the R commands, the R output, and a brief commentary. Then I realized that it might be helpful to see a real example. So I made up a simple homework assignment to illustrate what I’m looking for.

### Assignment

1. Read in the data on various body measurements. A description is at
--> http://www.amstat.org/publications/jse/datasets/fat.txt
and the file can be found at 
--> http://www.amstat.org/publications/jse/datasets/fat.dat.txt
Display the first few rows and the last few rows of the data.

2. List all of the bmi values.

3. List the last row of the data set only.

4. Calculate a summary for bmi.

5. Draw a histogram for bmi and interpret it.

6. Show the association between age and bmi using a correlation.

Here's how you would do this using R Markdown and an html format.

### Answer to 1.

Here are the R commands to read in the file.

### New slide 

```{r q1}
fn <- "http://www.amstat.org/publications/jse/datasets/fat.dat.txt"
fd <- read.table(file=fn)
```

<div class="notes">

Here are the first few rows of the data set.

</div>

### New slide 

```{r q1a}
head(fd)
```

<div class="notes">
Here are the last few rows of the data set.

</div>

### New slide 

```{r q1b}
tail(fd)
```

<div class="notes">

### Answer to 2. 

Here are all the bmi values.

</div>

### New slide 

```{r q2}
names(fd) <- c("case","fat.b","fat.s","dens","age","wt","ht","bmi","ffw","neck","chest","abdomen","hip","thigh","knee","ankle","biceps","forearm","wrist")
fd$bmi
```

<div class="notes">

### Answer to 3.

Here is the last row of the data.

</div>

### New slide 

```{r q3}
fd[252, ]
```

<div class="notes">

### Answer to 4. 

Here is a summary for bmi.

</div>

### New slide 

```{r q4}
summary(fd$bmi)
```

<div class="notes">

[[NOTE: INTERPRETATION IS IMPORTANT, BOTH HERE AND FOR THE NEXT TWO QUESTIONS. You don't have to describe every single number, just pick two or three to talk about.]] Rounding to two significant figures, the mean is 25, the range is 18 to 49.

### Answer to 5. 

Here is a histogram for bmi.

</div>

### New slide ```{r q5}
hist(fd$bmi)
```

<div class="notes">

The distribution is slightly skewed with a possible outlier between 45 and 50.

### Answer to 6.

Here is a correlation between bmi and age.

</div>

### New slide 

```{r q6}
cor(fd$bmi, fd$age)
```

<div class="notes">

The correlation is 0.12. There is little or no association between bmi and age.

Concluding remarks. What you see here is only a suggestion. Feel free to create a format that you like. The three things I am looking for is a listing of the R commands that you used, the text or graphical output, and a brief interpretation.

I noticed several of the students having trouble with adding a smooth curve to a scatterplot, and it really isn't their fault. I have been using R forclose to fiften years, which is mostly good, but it is bad because I tend to use approaches that worked with early versions of R rather than more recent approaches. I guess the term for this is that I'm "old school". But this old can learn a few new tricks, so let me explain why the old school approach to adding a smooth curve is sub-optimal and how the new approach using the ggplot2 library is better.

First, you need to download the ggplot2 package.

</div>

### New slide 

```{r download-ggplot2, eval=FALSE}
# You only need to do this once, then put eval=FALSE in the line above from that point onward.
install.packages("ggplot2")
```

<div class="notes">

There are two functions built into R for scatterplot smoothing. The first is lowess and the second is loess. Both use a locally weighted average and you control the degree of smoothness by varying the size of the window. A wide window does a lot of smoothing and a narrow window does much less smoothing.

The programs work okay, but are suboptimal for several reasons.

1. They will sometimes choke on data sets with lots of ties among the independent variables.

2. They will sometimes choke on data sets with missing values.

3. They do not have a data= argument in variable list, forcing you to type the data frame name twice.

4. They do not plot well if your data is not sorted properly. Here's a quick example of some of the problems you might see.

</div>

### New slide 

<div class="notes">

The sleep in mammals data set offers a nice example of why lowess and loess are suboptimal.

</div>

### New slide 

```{r lowess-plot}
plot(log(sl$BodyWt), sl$TotalSleep)
lowess_fit <- lowess(x=log(sl$BodyWt), y=sl$TotalSleep)
lines(lowess_fit)
```

<div class="notes">

Pretty ugly. The breaks in the lines are caused by missing values, and a time-saving feature where the smoothing curve uses interpolation instead of smoothing on consecutive data points that are close to one another.You can fix this by removing the missing values.

</div>

### New slide 

```{r lowess-plot-fix1}
sl1 <- sl[is.finite(sl$TotalSleep), ]
plot(log(sl1$BodyWt), sl1$TotalSleep)
lowess_fit <- lowess(x=log(sl1$BodyWt), y=sl1$TotalSleep)
lines(lowess_fit)
```

<div class="notes">

The loess function also has some issues.

</div>

### New slide 

```{r loess-plot}
plot(log(sl$BodyWt), sl$TotalSleep)
loess_fit <- loess(sl$TotalSleep~log(sl$BodyWt))
lines(loess_fit)
```

<div class="notes">

There are two problems here. The first is that the object created by loess differs from the object created by lowess in that the vector y inside the loess object is the original Y values, not the smoothed values. So sending the loess object to the lines function is like playing connect-the-dots.

You need to use the predict function, but even this has issues.

</div>

### New slide 

```{r loess-plot-fix1}
plot(log(sl$BodyWt), sl$TotalSleep)
loess_fit <- loess(sl$TotalSleep~log(sl$BodyWt))
lines(loess_fit$x, predict(loess_fit))
```

<div class="notes">

What's happening here is that the loess object lists the X values in the original order of the data set. Here are arrows showing the first six steps in drawing the smooth curve.

</div>

### New slide 

```{r loess-plot-fix2}
par(mfrow=c(2,3))
for (j in 2:7) {
  plot(log(sl$BodyWt), sl$TotalSleep)
  loess_fit <- loess(sl$TotalSleep~log(sl$BodyWt))
  lines(loess_fit$x[1:j], predict(loess_fit)[1:j])
  arrows(loess_fit$x[j-1], predict(loess_fit)[j-1], 
         loess_fit$x[j],   predict(loess_fit)[j], 
         length=0.1, col="red", lwd=3)
}
```

<div class="notes">

You can sort the data before or after the loess function, but doing it beforehand is simpler.

</div>

### New slide 

```{r loess-plot-fix3}
# The log function is monotone increasing so it doesn't
# change the order  from the original values of BodyWt.
o <- order(sl$BodyWt)
sl2 <- sl[o, ]
plot(log(sl2$BodyWt), sl2$TotalSleep)
loess_fit <- loess(sl2$TotalSleep~log(sl2$BodyWt))
lines(loess_fit$x, predict(loess_fit))
```

<div class="notes">

There is a better approach to drawing a smooth curve using a new library, ggplot2. The syntax for ggplot2 seems a bit odd at first, but it has the advantage of using a consistent approach to drawing graphs.

</div>

### New slide 

```{r ggplot2}
library(ggplot2)
ggplot(data=sl, aes(x=log(BodyWt), y=TotalSleep)) + geom_point() + geom_smooth()
```

<div class="notes">

Notice that the missing values are handled gracefully (with a warning even!) and that the order of the data is not an issue. The ggplot function sets up the general framework for the graph and then you add layers of information with the geom_point and geom_smooth functions. I dislike the confidence bands that are drawn by default, and you can turn these off with the se=FALSE argument in geom_smooth.

I am thinking about revising the material in this class for the next iteration, and one of the biggest changes will be presenting all the graphs using the ggplot2 library.

If you want to learn more about ggplot2, a nice starting point is

https://rpubs.com/hadley/ggplot-intro

</div>