---
title: "Introduction to R, module05"
author: "Steve Simon"
date: "Created 2020-04-02"
output: powerpoint_presentation
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo=TRUE)
``` 

### Introduction

This Powerpoint presentation was created using an R Markdown file. It is always a good idea to print the version of R and the current date as the very first few lines of any R program.

```{r r-version-and-current-date}
R.version.string
Sys.Date()
```

<div class="notes">

The version of R is stored in an internal constant, R.version.string. You can find the current data with the Sys.Date() function.

</div>


# Part 4a. Defining alternate storage formats

I'm going to use the term "longitudinal" data to designate data sets where a patient is measured at multiple different time points. This encompasses certain other data sets, such as from a crossover, pre-test/post-test, repeated measures, and split plot.

Don't worry about the technical distinctions among these terms. The important thing to know for now is that longitudinal data represents one of the biggest challenges in data management and we will spend most of this section discussing these challenges.

Longitudinal data usually come in one of two specific formats. The first is the short and fat format and the second is the tall and thin format. Open these two webpages in Internet explorer to see the difference. 

--> http://www.statsci.org/data/oz/ctsibrm.txt

--> http://www.statsci.org/data/oz/ctsibuni.txt

A description of the context for these files is at

--> http://www.statsci.org/data/oz/ctsib.html

The short and fat format has one row per patient and each successive patient encounter is strung out horizontally.

The tall and thin format has one row per patient encounter and therefore multiple rows per patient.

Both formats have advantages and disadvantages, and you need to know how to create a longitudinal file in either format and how to transform from one format to another.

Short and fat advantages:

1. easy to compute change scores
2. easy to examine correlations over time
3. easy to insure consistency of demographic data

Short and fat disadvantages:

1. hard to read because of the excessive need to scroll left and right

Tall and thin advantages:

1. easy to plot longitudinal trends
2. less need for missing value codes
3. easy to read because most scrolling is up and down

Tall and thin disadvantages

1. hard to maintain consistency of demographic variables


Here is a data set on termite survival. It is probably a bit of a stretch to call this longitudinal data, but it still is useful for illustrating how to convert longitudinal data.

The data is embedded in the description of the file. So you need to strip away the description from the data. It helps to import the data as entire lines, and you do this by specifying a separator character that is not
found anywhere in the file.

```{r read-termites-1}
fi <- "http://lib.stat.cmu.edu/DASL/Datafiles/Termites.html"
te.tst <- read.table(file=fi,sep="~")
te.tst[1:40,]
tail(te.tst)
```

If you look at the first 40 lines, it is obvious that the data starts
somewhere around line 35. and that every previous line (and the very
last line) start with an html tag. The comment argument allows us to
skip any line starting with an html tag. 

Also note the prevalence of "\t" values. These show that the data
itself is a tab-delimited file.

This is one of those cute R tricks that I tend to like, but if you
prefer, you could just cut-and-paste just the lines that you
want from the webpage and store the results in a text editor like
notepad.

```{r read-termites-2}
te <- read.table(file=fi, header=TRUE, comment="<")
head(te)
tail(te)
summary(te)
```

We need to re-organize this data before we can plot it.

```{r tedious-reshape}
sb01 <- te[,c("dish","dose","day1")]
names(sb01)[3] <- "count.living"
sb01$day <- 1
sb01

sb02 <- te[,c("dish","dose","day2")]
names(sb02)[3] <- "count.living"
sb02$day <- 2
sb02

sb04 <- te[,c("dish","dose","day4")]
names(sb04)[3] <- "count.living"
sb04$day <- 4

sb05 <- te[,c("dish","dose","day5")]
names(sb05)[3] <- "count.living"
sb05$day <- 5

sb06 <- te[,c("dish","dose","day6")]
names(sb06)[3] <- "count.living"
sb06$day <- 6

sb07 <- te[,c("dish","dose","day7")]
names(sb07)[3] <- "count.living"
sb07$day <- 7

sb08 <- te[,c("dish","dose","day8")]
names(sb08)[3] <- "count.living"
sb08$day <- 8

sb10 <- te[,c("dish","dose","day10")]
names(sb10)[3] <- "count.living"
sb10$day <- 10

sb11 <- te[,c("dish","dose","day11")]
names(sb11)[3] <- "count.living"
sb11$day <- 11

sb12 <- te[,c("dish","dose","day12")]
names(sb12)[3] <- "count.living"
sb12$day <- 12

sb13 <- te[,c("dish","dose","day13")]
names(sb13)[3] <- "count.living"
sb13$day <- 13

sb14 <- te[,c("dish","dose","day14")]
names(sb14)[3] <- "count.living"
sb14$day <- 14

sb15 <- te[,c("dish","dose","day15")]
names(sb15)[3] <- "count.living"
sb15$day <- 15

tea <- rbind(sb01, sb02, sb04, sb05, sb06, sb07, sb08,
             sb10, sb11, sb12, sb13, sb14, sb15)
head(tea)
tail(tea)
```

That's a bit tedious, and a clever R programmer could find a way to use looping structures like "for" to shorten the code. But there is a specialized library, tidyr, that makes things even easier.

The tidyr library allows you to switch from short and fat to tall and thin using the gather function.

```{r faster-1}
library("tidyr")
teb <- gather(te, day, count.living, -dish, -dose)
head(teb)
tail(teb)
```

It takes a bit of investigation, but the warning messages refer to the day3 and day9 values which are character strings. You can fix this by droping those columns.

```{r faster-2}
tec <- gather(te[,c(-5,-11)], day, count.living, -dish, -dose)
head(tec)
tail(tec)
```

We're not done quite yet. The day of the week is hidden in the variable
called "variable" and we need to keep only the fourth (and maybe fifth)
characters.

```{r substr-1}
substr(tec$day,4,5)
```

Almost. We need to convert from character to numeric.

```{r substr-2}
tec$day <- as.numeric(substr(tec$day,4,5))
head(tec)
tail(tec)
```

Now to plot the data.

```{r plot-termites}
plot(tec$day,tec$count.living)
```

Let's connect the data for individual subjects.

```{r line-termites}
plot(tec$day,tec$count.living)
for (i in 1:8) {
  sb <- tec$dish==i&tec$dose==5
  lines(tec$day[sb],tec$count.living[sb],col="darkred")
  sb <- tec$dish==i&tec$dose==10
  lines(tec$day[sb],tec$count.living[sb],col="darkgreen")
}
```

If you look at the graph, there are a couple of green lines, which
represent dose=10, but which have many more alive at day 15 than even
the dose=5 values. If you look at the original data set, these are
rows 9 and 10, corresponding to the first two dishes in the dose=10
group. This may be okay, but you should check with the people who 
collected the data, if you can.

## A data set on depression after an earthquake (short and fat format)

This data set is described in 
--> http://www.statsci.org/data/general/lomaprie.html


```{r read-earthquake}
fn <- "http://www.statsci.org/data/general/lomaprie.txt"
qu <- read.table(fn,header=TRUE)
qu
```

## On your own

Convert this to a tall and thin format. Draw boxplots.

Suggestion: create an id variable with values 1:25 before you convert the format. It is not needed for the boxplots, but if you do anything more complex with this data, you need to know which data in the tall and thin format comes from the first rows of the original data set, from the second row, etc.

## A data set on energy consumption (short and fat format)

Here's another interesting data set that you can work with. It comes in a short and fat format.

--> http://www.statsci.org/data/general/energy.html

```{r read-energy}
fi <- "http://www.statsci.org/data/general/energy.txt"
en <- read.table(fi,header=TRUE)
head(en)
tail(en)
```

## Converting from tall and thin to short and fat

Now let's read in a tall and thin format and convert it to a
short and wide format.

This data set is described at 

--> http://www.statsci.org/data/general/cholest.html

```{r chol-read}
fi <- "http://www.statsci.org/data/general/cholestg.txt"
ch <- read.table(fi,header=TRUE)
head(ch)
tail(ch)
summary(ch)
```

The summary is not too helpful for the first three variables, so 
try the table command instead.

```{r chol-table}
table(ch$patient,useNA="always")
table(ch$group,useNA="always")
table(ch$day,useNA="always")
```

It's still a bit confusing. Why do the first 28 subjects have three
measurements and the last 30 have only one measurement.

```{r chol-crosstabs}
table(ch$patient,ch$day,useNA="always")
table(ch$group,ch$day,useNA="always")
```

Okay, now it's a bit more clear. Each subject has measurements on
three days (2,4,14) for group one, and measurements on an unspecified
day (NA) for group 2.

Let's look at the tedious and the faster way to convert from the tall
and thin to the short and fat format.

The missing value for day is going to cause a lot of grief, and it is
simpler here to change it to a special code, 99.

```{r chol-reshape-1}
ch$day[is.na(ch$day)] <- 99

sb02 <- ch[ch$day==2,c(1,4)]
names(sb02)[2] <- "cholest02"
head(sb02)

sb04 <- ch[ch$day==4,c(1,4)]
names(sb04)[2] <- "cholest04"
head(sb04)

sb14 <- ch[ch$day==14,c(1,4)]
names(sb14)[2] <- "cholest14"
head(sb14)

sb99 <- ch[ch$day==99,c(1,4)]
names(sb99)[2] <- "cholest99"
head(sb99)

me1 <- merge(sb02,sb04,by="patient")
head(me1)
tail(me1)

me2 <- merge(me1,sb14,by="patient")
head(me2)
tail(me2)

me3 <- merge(me2,sb99,by="patient")
head(me3)
tail(me3)
```

Oops! What happened here is that no matches were found and the default
in the merge function is to only include in the merge those rows that
are found in both data sets. This is known as an inner join in database
parlance. You can use the all.x and all.y arguments to use a left join,
right join, or outer join instead.

```{r chol-reshape2}
me3 <- merge(me2,sb99,by="patient",all.x=TRUE,all.y=TRUE)
head(me3)
tail(me3)
```

```{r chol-reshape-3}
library("tidyr")
ch1 <- spread(ch, day, cholest)
head(ch1)
tail(ch1)
cor(ch1[,c("2", "4", "14")])
```

Oops! The missing values hurt us here. Review the help file for cor.

```{r cholest-cor}
cor(ch1[,c("2", "4", "14")],use="complete")
```

## A data set on back pain with two matched control groups

This data set is described in
--> http://www.statsci.org/data/oz/backpain.html

Subjects were matched by age, height, and weight. How well were they matched?

```{r read-match}
fn <- "http://www.statsci.org/data/oz/backpain.txt"
ma <- read.table(fn,header=TRUE)
ma <- ma[,1:6]
head(ma)
tail(ma)
```

## On your own

Convert this to a short and fat format. Let age1 represent the age of
the subject in the pain group, age2 represent the matched subject
in the nopain group, and age3 represent the matched subject in the
sedentary group. Redefine height and weight similarly.

Plot age1 versus age2 and age1 versus age3 to evaluate how closely
the subjects are matched on age. Repeat for height and weight.

## If there is extra time

Here is a very complex data set on stroke.
--> http://www.statsci.org/data/oz/stroke.html

```{read-stroke}
fi <- "http://www.statsci.org/data/oz/stroke.txt"
st <- read.table(fi,header=TRUE)
head(st)
tail(st)
```



```{r save-image, echo=FALSE}
save.image("../data/slides06.RData")
```
