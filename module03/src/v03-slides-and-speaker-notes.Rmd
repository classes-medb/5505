---
title: "Module02: Data with mostly continuous variables"
author: "Steve Simon"
date: "Created 2020-02-08"
output: powerpoint_presentation
---

```{r echo=FALSE}
suppressMessages(suppressWarnings(library(stringr)))
options(width=45)
```

### New slide 

<div class="notes">


The material for Part 1 did not include enough information about getting data into and out of R. Here are a few extra examples.

</div>

### Read in comma separated values

<div class="notes">

The read.csv function will read a text file with commas separating individual data points. This is a commonly used format and frequently has the extension .csv.

In notepad or another text editor, type in the following
values.

1,4

2,8

3,12

4,16

and save the file using the name simple.csv. Note the directory that you are saving it in.

Here's a time saving hint: run the getwd function without any arguments (getwd()) to see where the current working directory. This is the place that R is currently looking for files if you don't provide a path. If you store the file simple.csv in the current working directory, then you don't have to type in the path name as well as the filename.

You can use the setwd command to change the current working directory. Be sure to use forward slashes (/) in your pathname rather than backslashes (\).

</div>

### New slide 

```{r read-csv}
fn <- "../dat/simple.csv"
d1 <- read.csv(file=fn)
d1
```

<div class="notes">

Oops! That didn't work the way I wanted it to. Look at the help file for read.csv. What option would you use to avoid losing the first line of data?

### On your own  (do this, but you do not need to turn in anything to me)

Add the line x,y to the top of your csv file and read it in using the header=TRUE option.

Note: depending on how you typed your data, you may or may not get an error message like "Warning in readLines(file, n = thisblock): incomplete final line found"

This happens when R does not find a carriage return at the end of the last line of data. This is easily fixed by opening the text file and going to the very end with CTRL-END.

if you land at the end of the very last line, you don't have a final carriage return. If you land on a blank line below the last line of text, then you are fine.

### Using the more general function, read.table

<div class="notes">

Review the options for the read.table command.

Type in the same data, but using the tilde (~) as a separator (e.g., 1~4). Save the file as tilde.txt.

Here is how you would use read.table to read this file.

</div>

### Reading in space delimited files.

```{r read-table}
fn <- "../dat/tilde.txt"
d2 <- read.table(file=fn,header=TRUE,sep="~")
```

<div class="notes">

Open up notepad and type in the following lines.

1  4

2  8

3 12

4 16

Be sure to line up the numbers properly by inserting two blanks between 1 and 4 and two blanks between 2 and 8, but only one blank between 3 and 12 and between 4 and 16.

Save the file as space.txt.

If you tried to read in the file with sep=" ", you would get an error. Try this to see what the error looks like.


You can either always edit the file and replace any double blanks with single blanks, but if you look carefully at the help file, you will see that the argument sep="" (which is the default) will use white space (one or more blanks, tabs, carriage returns, or newlines). This works pretty well but not always. We will see a file where you have to fix things before you can import it properly.

</div>

### New slide 

```{r read-space}
fn <- "../dat/space.txt"
# Try read.table(fn,sep=" ") first.
d3 <- read.table(fn,sep="")
```

<div class="notes">

Note that the default for read.table is header=FALSE, as opposed to the default of HEADER=TRUE for read.csv.

</div>

### Reading fixed width format files

<div class="notes"

Sometimes you will get a file with no delimiters to save space. This requires that each variable takes up a fixed number of columns and that information is often specified in a separate file.

Create a fixed width file in notepad with the following lines.

1 4

2 8

312

416

and store it as fixed.txt.

</div>

### New slide 

```{r fixed}
fn <- "../dat/fixed.txt"
d4 <- read.fwf(fn,c(1,2))
d4
```

<div class="notes">

You should also consider the read.fortran function. Check out the help file.

### Writing text files

If you want to write a text file, you can use either the write.csv or write.table functions. Look up the help files on these functions. We'll create a small data frame and store it in a comma delimited and tab delimited format.

</div>

### New slide 

```{r write-text}
d5 <- data.frame(x=c(13,12,11),y=c(2,4,6))
fn <- "../results/output1.csv"
write.csv(d5,fn)
fn <- "../results/output2.txt"
write.table(d5,fn)
```

<div class="notes">

Open these files in notepad to see what they look like.

</div>

### On your own (do this, but you do not need to turn it anything to me)

To avoid the extra line at the top and the row names "1","2","3" use the options header=FALSE and col.names=FALSE. Try this and see what the two files look like now.

### Writing binary files

By default, R saves everything that you create on exiting from the program and stores it in a file with no name and with an extension of RData (in other words, .RData). This file is automatically loaded the next time you start R from the same subdirectory.

If you want to save a data frame in binary format, use the function save(). Binary formats are much faster but are pretty much useful only within R itself.

In other words, don't send a binary file to someone who does not have R. Binary files are useful when you are moving data from one R user to another, or data from one computer to another, or sometimes when you are moving data from one folder to another.


I had a student ask, “What, exactly, do I need to turn in for the homework assignments. I said that I’d like to see the R commands, the R output, and a brief commentary. Then I realized that it might be helpful to see a real example. So I made up a simple homework assignment to illustrate what I’m looking for.

### Assignment

1. Read in the data on various body measurements. A description is at
--> http://www.amstat.org/publications/jse/datasets/fat.txt
and the file can be found at 
--> http://www.amstat.org/publications/jse/datasets/fat.dat.txt
Display the first few rows and the last few rows of the data.

2. List all of the bmi values.

3. List the last row of the data set only.

4. Calculate a summary for bmi.

5. Draw a histogram for bmi and interpret it.

6. Show the association between age and bmi using a correlation.

Here's how you would do this using R Markdown and an html format.

### Answer to 1.

Here are the R commands to read in the file.

### New slide 

```{r q1}
fn <- "http://www.amstat.org/publications/jse/datasets/fat.dat.txt"
fd <- read.table(file=fn)
```

<div class="notes">

Here are the first few rows of the data set.

</div>

### New slide 

```{r q1a}
head(fd)
```

<div class="notes">
Here are the last few rows of the data set.

</div>

### New slide 

```{r q1b}
tail(fd)
```

<div class="notes">

### Answer to 2. 

Here are all the bmi values.

</div>

### New slide 

```{r q2}
names(fd) <- c("case","fat.b","fat.s","dens","age","wt","ht","bmi","ffw","neck","chest","abdomen","hip","thigh","knee","ankle","biceps","forearm","wrist")
fd$bmi
```

<div class="notes">

### Answer to 3.

Here is the last row of the data.

</div>

### New slide 

```{r q3}
fd[252, ]
```

<div class="notes">

### Answer to 4. 

Here is a summary for bmi.

</div>

### New slide 

```{r q4}
summary(fd$bmi)
```

<div class="notes">

[[NOTE: INTERPRETATION IS IMPORTANT, BOTH HERE AND FOR THE NEXT TWO QUESTIONS. You don't have to describe every single number, just pick two or three to talk about.]] Rounding to two significant figures, the mean is 25, the range is 18 to 49.

### Answer to 5. 

Here is a histogram for bmi.

</div>

### New slide ```{r q5}
hist(fd$bmi)
```

<div class="notes">

The distribution is slightly skewed with a possible outlier between 45 and 50.

### Answer to 6.

Here is a correlation between bmi and age.

</div>

### New slide 

```{r q6}
cor(fd$bmi, fd$age)
```

<div class="notes">

The correlation is 0.12. There is little or no association between bmi and age.

Concluding remarks. What you see here is only a suggestion. Feel free to create a format that you like. The three things I am looking for is a listing of the R commands that you used, the text or graphical output, and a brief interpretation.

I noticed several of the students having trouble with adding a smooth curve to a scatterplot, and it really isn't their fault. I have been using R forclose to fiften years, which is mostly good, but it is bad because I tend to use approaches that worked with early versions of R rather than more recent approaches. I guess the term for this is that I'm "old school". But this old can learn a few new tricks, so let me explain why the old school approach to adding a smooth curve is sub-optimal and how the new approach using the ggplot2 library is better.

First, you need to download the ggplot2 package.

</div>

### New slide 

```{r download-ggplot2, eval=FALSE}
# You only need to do this once, then put eval=FALSE in the line above from that point onward.
install.packages("ggplot2")
```

<div class="notes">

There are two functions built into R for scatterplot smoothing. The first is lowess and the second is loess. Both use a locally weighted average and you control the degree of smoothness by varying the size of the window. A wide window does a lot of smoothing and a narrow window does much less smoothing.

The programs work okay, but are suboptimal for several reasons.

1. They will sometimes choke on data sets with lots of ties among the independent variables.

2. They will sometimes choke on data sets with missing values.

3. They do not have a data= argument in variable list, forcing you to type the data frame name twice.

4. They do not plot well if your data is not sorted properly. Here's a quick example of some of the problems you might see.

</div>

### New slide 

<div class="notes">

The sleep in mammals data set offers a nice example of why lowess and loess are suboptimal.

</div>

### New slide 

```{r lowess-plot}
plot(log(sl$BodyWt), sl$TotalSleep)
lowess_fit <- lowess(x=log(sl$BodyWt), y=sl$TotalSleep)
lines(lowess_fit)
```

<div class="notes">

Pretty ugly. The breaks in the lines are caused by missing values, and a time-saving feature where the smoothing curve uses interpolation instead of smoothing on consecutive data points that are close to one another.You can fix this by removing the missing values.

</div>

### New slide 

```{r lowess-plot-fix1}
sl1 <- sl[is.finite(sl$TotalSleep), ]
plot(log(sl1$BodyWt), sl1$TotalSleep)
lowess_fit <- lowess(x=log(sl1$BodyWt), y=sl1$TotalSleep)
lines(lowess_fit)
```

<div class="notes">

The loess function also has some issues.

</div>

### New slide 

```{r loess-plot}
plot(log(sl$BodyWt), sl$TotalSleep)
loess_fit <- loess(sl$TotalSleep~log(sl$BodyWt))
lines(loess_fit)
```

<div class="notes">

There are two problems here. The first is that the object created by loess differs from the object created by lowess in that the vector y inside the loess object is the original Y values, not the smoothed values. So sending the loess object to the lines function is like playing connect-the-dots.

You need to use the predict function, but even this has issues.

</div>

### New slide 

```{r loess-plot-fix1}
plot(log(sl$BodyWt), sl$TotalSleep)
loess_fit <- loess(sl$TotalSleep~log(sl$BodyWt))
lines(loess_fit$x, predict(loess_fit))
```

<div class="notes">

What's happening here is that the loess object lists the X values in the original order of the data set. Here are arrows showing the first six steps in drawing the smooth curve.

</div>

### New slide 

```{r loess-plot-fix2}
par(mfrow=c(2,3))
for (j in 2:7) {
  plot(log(sl$BodyWt), sl$TotalSleep)
  loess_fit <- loess(sl$TotalSleep~log(sl$BodyWt))
  lines(loess_fit$x[1:j], predict(loess_fit)[1:j])
  arrows(loess_fit$x[j-1], predict(loess_fit)[j-1], 
         loess_fit$x[j],   predict(loess_fit)[j], 
         length=0.1, col="red", lwd=3)
}
```

<div class="notes">

You can sort the data before or after the loess function, but doing it beforehand is simpler.

</div>

### New slide 

```{r loess-plot-fix3}
# The log function is monotone increasing so it doesn't
# change the order  from the original values of BodyWt.
o <- order(sl$BodyWt)
sl2 <- sl[o, ]
plot(log(sl2$BodyWt), sl2$TotalSleep)
loess_fit <- loess(sl2$TotalSleep~log(sl2$BodyWt))
lines(loess_fit$x, predict(loess_fit))
```

<div class="notes">

There is a better approach to drawing a smooth curve using a new library, ggplot2. The syntax for ggplot2 seems a bit odd at first, but it has the advantage of using a consistent approach to drawing graphs.

</div>

### New slide 

```{r ggplot2}
library(ggplot2)
ggplot(data=sl, aes(x=log(BodyWt), y=TotalSleep)) + geom_point() + geom_smooth()
```

<div class="notes">

Notice that the missing values are handled gracefully (with a warning even!) and that the order of the data is not an issue. The ggplot function sets up the general framework for the graph and then you add layers of information with the geom_point and geom_smooth functions. I dislike the confidence bands that are drawn by default, and you can turn these off with the se=FALSE argument in geom_smooth.

I am thinking about revising the material in this class for the next iteration, and one of the biggest changes will be presenting all the graphs using the ggplot2 library.

If you want to learn more about ggplot2, a nice starting point is

https://rpubs.com/hadley/ggplot-intro

</div>